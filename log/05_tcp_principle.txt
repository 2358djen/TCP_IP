#include "../include/func.h"

write() -> 输出缓冲 -> ... -> 输入缓冲 -> read()
I/O 缓冲在每个TCP套接字中自动生成
I/O 缓冲在创建套接字时自动生成
即使关闭套接字也会继续传输输出缓冲中的缓冲遗留的数据
关闭套接字将会丢失输入缓冲中的数据

TCP存在滑动窗口(Sliding Window)协议,因此TCP中不会因为缓冲溢出而丢失数据
write()函数在将数据转移到输出缓冲后返回,但TCP会保证对输出缓冲数据的传输

三次握手:
A:"你好,套接字B,我有数据要传输给你,建立连接吧"
B:"好的,我这边已经就绪"
A:"谢谢你受理我的请求"



TCP内部工作原理1: 与对方套接字的连接 
套接字是以全双工(Full-duplex)方式工作的
1. A -> B [SYN] SEQ:1000, ACK:-
    SEQ:"现在传递的数据包序号是1000,如果接受无误,请通知我向您传递1001号数据包"

2. B -> A [SYN+ACK] SEQ:2000, ACK:1001
    SEQ:"现在传递的数据包序号是2000,如果接受无误,请通知我向您传递2001号数据包"
    ACK:"现在请传输1001的数据包 (刚才传输的SEQ为1000的数据包接收无误)"

3. A -> B [ACK] SEQ:1001, ACK:2001
    SEQ:"现在传递的数据包序号是1001,如果接受无误,请通知我向您传递1002号数据包"
    ACK:"现在请传输2001的数据包 (刚才传输的SEQ为2000的数据包接收无误)"

[SYN]:收发数据前的同步消息, [SYN+ACK]:同步消息+准备传输的消息捆绑发送, [ACK]:传输消息



TCP内部工作原理2: 与对方的主机的数据交换
通过第一步三次握手完成了数据交换准备,开始收发数据
1. A -> B [SEQ] 1200  100 byte data
2. B -> A [ACK] 1301
3. A -> B [SEQ] 1301  100 byte data
4. B -> A [ACK] 1402
ACK号 = SEQ号 + 传递的字节数 + 1 (加1是为了告诉对方下次要传递的SEQ号)

1. A -> B [SEQ] 1200  100 byte data
2. B -> A [ACK] 1301
3. A -> B [SEQ] 1301  100 byte data
    ...超时(未收到[ACK]),重发
4. A -> B [SEQ] 1301  100 byte data
5. B -> A [ACK] 1402



TCP内部工作原理3: 断开与套接字的连接
A:"请求断开连接"
B:"请稍后"
...
B:"准备就绪,可以断开连接"
A:"合作愉快!"

1. A -> B [FIN] SEQ:5000, ACK:-
2. B -> A [ACK] SEQ:7500, ACK:5001
3. B -> A [FIN] SEQ:7501, ACK:5001
4. A -> B [ACK] SEQ:5001, ACK:7502
[FIN]表示断开连接,即双方个发一次FIN后断开连接
其中B -> A发送了两次ACK:5001,其实第二次的FIN中的ACK:5001只是因为接收ACK消息后未接收数据而重传的